/*
 * Weird multichannel DAC, using an FT2232H to bit-bang
 * I2S in sync with a clock generated by a Si5351.
 *
 * Requires https://github.com/devttys0/libmpsse
 */

/*
 * Copyright (c) 2015 Micah Elizabeth Scott <micah@misc.name>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#pragma once
#include <stdint.h>
#include <tinythread.h>
extern "C" {
    #include <mpsse.h>
}


class MultiDAC
{
public:
    static const unsigned kNumChannels = 9;      // Supports up to 14 with this scheme

    static const unsigned kBitsPerSample = 24;   // Must match DAC and clock generator setup
    static const unsigned kSampleRate = 48000;

    struct Sample {
        int32_t ch[kNumChannels];
    };

    typedef void (*Callback_t)(Sample *buffer, unsigned num_samples, void *userdata);

    // Starts the audio thread, which initializes the device then begins invoking the callback.
    // Returns false on error.
    bool start(Callback_t fn, void *userdata);

private:
    // Configured in the EEPROM, which must be written anyway to set the FIFO mode.
    static const unsigned kUSBVendorId = 0xe461;
    static const unsigned kUSBProductId = 0x0015;

    // USB buffers. Enough for a few USB frames.
    static const unsigned kBytesPerBuffer = 1024;
    static const unsigned kNumBuffers = 4;

    Callback_t callback;
    void *callback_data;

    struct {
        ftdi_transfer_control *tc;
        uint8_t data[kBytesPerBuffer];
    } buffers[kNumBuffers];
};


/*****************************************************************************************
 *                                   Implementation
 *****************************************************************************************/


inline bool MultiDAC::start(Callback_t fn, void *userdata)
{
    callback = fn;
    callback_data = userdata;

    // Configure the clock generator using a canned I2C register write sequence,
    // generated with the help of a tool from the chip vendor. For more details,
    // see the data sheet or Adafruit's Si5351 library.
    //
    // We use CLK0 to drive the RD# strobe, and CLK1 to drive the I2S bit clock.
    // The two outputs must be locked to the same frequency, but this hardware setup
    // lets us tune the relative phase of the two clocks. Data is valid when RD# is low,
    // and the rising edge of the I2S clock must occur while RD# is low.
    //
    // The clock rate for I2S is (sample rate * bits per sample * channels). We generate stereo
    // 48 kHz 24-bit I2S frames, so our clock rate should be 2.304 MHz.

    struct mpsse_context *clkgen = Open(kUSBVendorId, kUSBProductId, I2C, FOUR_HUNDRED_KHZ, MSB, IFACE_B, 0, 0);
    if (!clkgen->open) {
        fprintf(stderr, "Failed to open MultiDAC device: %s\n", ErrorString(clkgen));
        return false;
    }

    #define code
    #include "lib/si5351a_register_map.h"
    #undef code
    const uint8_t i2c_address = 0x60;

    for (unsigned i = 0; i < NUM_REGS_MAX; i++) {
        uint8_t addr = Reg_Store[i].Reg_Addr;
        uint8_t value = Reg_Store[i].Reg_Val;
        if (addr == 0) {
            break;
        }

        char cmd[3] = { i2c_address << 1, addr, value };

        Start(clkgen);
        Write(clkgen, cmd, sizeof cmd);
        int ack = GetAck(clkgen);
        Stop(clkgen);

        if (ack != ACK) {
            fprintf(stderr, "Error communicating with the Si5351a clock generator\n");
            Close(clkgen);
            return false;
        }
    }

    Close(clkgen);

    // Now the clock is running and we can go back to libftdi, and start shoveling data into
    // the asynchronous FIFO on channel A. In each byte D7 is the L/R word clock, and
    // the other bits are available to drive individual stereo DACs wired in parallel.

    // Open the device here in case it errors, then move to another thread where we'll
    // continuously pump buffers full of formatted audio data into the FIFO.

    struct ftdi_context *ftdi = ftdi_new();
    if (ftdi_usb_open(ftdi, kUSBVendorId, kUSBProductId) < 0) {
        fprintf(stderr, "Failed to reopen MultiDAC after clock init: %s", ftdi_get_error_string(ftdi));
        return false;
    }



unsigned char block[512];
for (int i = 0; i < sizeof block; i++)
 block[i] = (i&1) ? 0xFF : 0x00;
while (ftdi_write_data(ftdi, block, sizeof block) > 0);

    return true;
}
