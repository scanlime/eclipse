/*
 * Weird multichannel DAC, using an FT2232H to bit-bang
 * I2S in sync with a clock generated by a Si5351.
 *
 * Requires https://github.com/devttys0/libmpsse
 */

/*
 * Copyright (c) 2015 Micah Elizabeth Scott <micah@misc.name>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#pragma once
#include <stdint.h>
#include "lib/tinythread.h"
extern "C" {
    #include <ftdi.h>
    #include <mpsse.h>
}


class MultiDAC
{
public:
    static const unsigned kNumChannels = 9;      // Supports up to 14 with this scheme. Lower numbers save some CPU.
    static const unsigned kBitsPerSample = 24;   // The DAC supports 16, 24 or 32 bits
    static const unsigned kSampleRate = 48000;   // The sample rate and bits per sample must match the clock generator setup

    struct Frame {
        int32_t ch[kNumChannels];
    };

    typedef void (*Callback_t)(Frame *buffer, unsigned num_frames, void *userdata);

    // Starts the audio thread, which initializes the device then begins invoking the callback.
    // Returns false on error.
    bool start(Callback_t fn, void *userdata);

private:
    // Configured in the EEPROM, which must be written anyway to set the FIFO mode.
    static const unsigned kUSBVendorId = 0xe461;
    static const unsigned kUSBProductId = 0x0015;

    static const unsigned kAudioFramesPerBuffer = 64;
    static const unsigned kBytesPerBuffer = kAudioFramesPerBuffer * kBitsPerSample * 2;
    static const unsigned kNumBuffers = 4;

    Callback_t callback;
    void *callback_data;
    tthread::thread *thread;
    struct ftdi_context *ftdi;

    struct {
        struct ftdi_transfer_control *tc;
        uint8_t data[kBytesPerBuffer];
    } buffers[kNumBuffers];

    Frame mix_buffer[kAudioFramesPerBuffer];

    static void threadFunc(void *arg);
    void submitBuffer(unsigned n);
};


/*****************************************************************************************
 *                                   Implementation
 *****************************************************************************************/


inline bool MultiDAC::start(Callback_t fn, void *userdata)
{
    callback = fn;
    callback_data = userdata;

    // Configure the clock generator using a canned I2C register write sequence,
    // generated with the help of a tool from the chip vendor. For more details,
    // see the data sheet or Adafruit's Si5351 library.
    //
    // We use CLK0 to drive the RD# strobe, and CLK1 to drive the I2S bit clock.
    // The two outputs must be locked to the same frequency, but this hardware setup
    // lets us tune the relative phase of the two clocks. Data is valid when RD# is low,
    // and the rising edge of the I2S clock must occur while RD# is low.
    //
    // The clock rate for I2S is (sample rate * bits per sample * channels). We generate stereo
    // 48 kHz 24-bit I2S frames, so our clock rate should be 2.304 MHz.

    struct mpsse_context *clkgen = Open(kUSBVendorId, kUSBProductId, I2C, FOUR_HUNDRED_KHZ, MSB, IFACE_B, 0, 0);
    if (!clkgen->open) {
        fprintf(stderr, "Failed to open MultiDAC device: %s\n", ErrorString(clkgen));
        return false;
    }

    #define code
    #include "lib/si5351a_register_map.h"
    #undef code
    const uint8_t i2c_address = 0x60;

    for (unsigned i = 0; i < NUM_REGS_MAX; i++) {
        uint8_t addr = Reg_Store[i].Reg_Addr;
        uint8_t value = Reg_Store[i].Reg_Val;
        if (addr == 0) {
            break;
        }

        char cmd[3] = { i2c_address << 1, addr, value };

        Start(clkgen);
        Write(clkgen, cmd, sizeof cmd);
        int ack = GetAck(clkgen);
        Stop(clkgen);

        if (ack != ACK) {
            fprintf(stderr, "Error communicating with the Si5351a clock generator\n");
            Close(clkgen);
            return false;
        }
    }

    Close(clkgen);

    // Now the clock is running and we can go back to libftdi, and start shoveling data into
    // the asynchronous FIFO on channel A. In each byte D7 is the L/R word clock, and
    // the other bits are available to drive individual stereo DACs wired in parallel.

    // Open the device here in case it errors, then move to another thread where we'll
    // continuously pump buffers full of formatted audio data into the FIFO.

    ftdi = ftdi_new();
    if (ftdi_usb_open(ftdi, kUSBVendorId, kUSBProductId) < 0) {
        fprintf(stderr, "Failed to reopen MultiDAC after clock init: %s", ftdi_get_error_string(ftdi));
        return false;
    }

    memset(buffers, 0, sizeof buffers);
    thread = new tthread::thread(threadFunc, this);
    return true;
}

inline void MultiDAC::threadFunc(void *arg)
{
    MultiDAC *self = static_cast<MultiDAC*>(arg);
    while (1) {
        for (unsigned i = 0; i < kNumBuffers; i++) {
            self->submitBuffer(i);
        }
    }
}

inline void MultiDAC::submitBuffer(unsigned n)
{
    // Wait for the buffer in this slot to complete, if necessary.
    if (buffers[n].tc) {
        ftdi_transfer_data_done(buffers[n].tc);
        buffers[n].tc = 0;
    }

    callback(mix_buffer, kAudioFramesPerBuffer, callback_data);

    // Assemble the I2S waveform
    uint8_t *dest = buffers[n].data;
    for (unsigned frame = 0; frame < kAudioFramesPerBuffer; frame++) {
        for (unsigned lrck = 0; lrck < 2; lrck++) {
            for (unsigned bit = 0; bit < kBitsPerSample; bit++) {
                uint8_t byte = lrck << 7;
                for (unsigned channel = lrck; channel < kNumChannels; channel += 2) {
                    int32_t pcm = mix_buffer[frame].ch[channel];
                    byte |= ((pcm >> (kBitsPerSample - 1 - bit)) & 1) << (channel >> 1);
                }
                *(dest++) = byte;
            }
        }
    }

    buffers[n].tc = ftdi_write_data_submit(ftdi, buffers[n].data, kBytesPerBuffer);
}
